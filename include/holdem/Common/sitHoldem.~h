//---------------------------------------------------------------------------

#ifndef sitHoldemH
#define sitHoldemH
//---------------------------------------------------------------------------
#include "c:\Work\Holdem\ArrCnPlayer.h"
#include "c:\Work\Holdem\HistTable.h"

enum enSitName {SIT_CLEARWATER=0,SIT_LIMP,SIT_RAISE,SIT_RAISE2,SIT_HORROR,SIT_REPLY,SIT_UNDEF};

#define CN_SIT  SIT_UNDEF

enum enTradeAction  {TA_RAISE,TA_RAISE_FOLD,TA_RAISE_CALL,TA_RAISE_RAISE,TA_RAISE_ALL_IN,
    TA_BET,TA_BET_FOLD,TA_BET_CALL,TA_BET_RAISE,TA_BET_ALL_IN,
    TA_CHECK,TA_CHECK_FOLD,TA_CHECK_CALL,TA_CHECK_RAISE,TA_CHECK_MINIRAISE,TA_CHECK_ALL_IN,
    TA_LIMP,TA_CALL,TA_UNDEF};

class clStacks : public clIntCP
{
public:
    void Norm(int sh);
    clDoubleCP ClaccisCS(int cnPl=-1);
    int     CnPlayer();
    inline  void    operator =(int val)     {*(clIntCP *)this=val;}
    void    MoveButton(int cnPl);

    int _bb;
};

clStacks    SitHGetStacks(clHistTable *table);
inline  int SitHoldemEffStack(int stack, int bb)        {return stack*100/bb;}

#define MAX_CNACT_SHORTSIT             10

/*class clShortSit
{
public:
    inline  clShortSit()            {_cnAct=0;}
//    int     Indicator();
    inline  enSitName   SitName()       {return (enSitName)_arrAct[9]._dis._act;}
    inline  int     Indicator()         {return _arrAct[9]._pos;}
    inline  void    WrSitName(enSitName ns)       {_arrAct[9]._dis._act=ns;}
    inline  void    WrIndicator(int ind)          {_arrAct[9]._pos=ind;}

    clStacks _stack;
    int _cnAct;
    tpAction _arrAct[MAX_CNACT_SHORTSIT];
};*/

class clSitHoldem : public clHistTable
{
public:
    clSitHoldem();
    void    Build(clGameHistory *ptrH,int nbAct=-1);
//    void    Build(clShortSit *ss);
    inline  int     Position()      {return _indicator;}
    inline  int     PosHero()       {return _posHero;}
    inline  void    SetPosHero(int pos)     {_posHero=pos;}
    bool    FirstSit();
    bool    NextSit();
    bool    NextSitPreFlop();
    void    SitForIndicator(int round=0);
    inline  int     StackIndicator()    {return PlMoney(Indicator());}
    inline  int     EffStackPlayer(int pos)     {return SitHoldemEffStack(PlMoney(pos),BigBlind());}
    inline  int     EffStackIndicator()         {return EffStackPlayer(Indicator());}
    int     EffStackSitForPlayer(int posH);
    inline  tpAction    *GetActIndicator()      {return GetAct(_nbAct);}
    inline  clCard  *IndicatorCards()           {return PlayerCards(Indicator());}
    inline  int CurAct()                {return _nbAct;}
    enSitName   NameSit();
    tpDis   CreateDis(enAction act,int money=0);
    inline  tpDis   CreateDis(tpDis dis)     {return CreateDis(dis._act,dis._money);}
    inline  int     IndicatorMoney()         {return PlayerMoney(Indicator());}
    int     RoundTrade();
    int     CnRaiser(tpAction *arrAct);
    int     CnRaiser();
    int     PosRaiser(int nb);
    int     CnLimper();
    int     CnLimper(tpAction *arrAct);
    clStacks    GetEffStacks();
    inline  clStacks    GetStacks()         {return SitHGetStacks(this);}
    double  HeroCSClassic();
    tpDis   ChangeDis(tpDis dis);
    bool    IsEqualDis(tpDis dis1,tpDis dis2);
    tpDis   CreateDisCallCheck();
    bool    NoFold();
    int     MaxBetForIndicator();
    enTradeAction   TradeActionPlayer(int nbPl,enNameTrade t);
    int     TotalPotForIndicator();
    bool    BoardInPosition();
    bool    IsPlayerInAllIn();
    tpDis   MinRaise();

private:
};

void    SHBuildHistToStacks(clGameHistory *hist,clStacks st);

bool    SitIsSitForCallTogether(clSitHoldem *sit);
bool    SitIsSitForRaiseTogether(clSitHoldem *sit);
bool    SitDisIsRaiseTogether(clSitHoldem *sit,tpDis dis);
bool    SitHoldemStacksForCallTogether(clStacks st);
bool    SitHoldemStacksForRaiseTogether(clStacks st);
AnsiString  SitHoldemSitToString(enSitName ns);
//---------------------------------------------------------------------------
#endif
